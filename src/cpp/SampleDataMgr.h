#pragma once

#include "SampleData.h"

namespace pongasoft {
namespace VST {
namespace SampleSplitter {

using namespace Steinberg;
using namespace GUI::Params;

/**
 * Manages SampleData lifecycle, from creation to undo/redo.
 *
 * \note This object is registered as a Jamba parameter and as a result is available via the state in all views
 *       and all controllers.
 */
class SampleDataMgr
{
private:
  /**
   * These objects are saved in the undo history in order to be replayed: `fAction` applied on `fSampleData` provides
   * the new SampleData
   */
  struct UndoEntry
  {
    UndoEntry(SampleDataAction iAction, SampleData iSampleData) :
      fAction{std::move(iAction)},
      fSampleData(std::move(iSampleData)){}

    SampleDataAction fAction;
    SampleData fSampleData;
  };

public:
  SampleDataMgr() = default;

  // required for Jmb
  SampleDataMgr(SampleDataMgr const &iOther);

  /**
   * Load the current sample from the given path (user selects a file in a file selection dialog or drag/drop
   * a file)
   *
   * @return `true` if successful, `false` otherwise
   */
  bool load(UTF8Path iPath)
  {
    auto action = SampleDataAction{SampleDataAction::Type::kLoad};
    action.fFilePath = std::move(iPath);
    return executeAction(action);
  }

  /**
   * Loads the current sample from the provided sample buffers (which is generated by the RT when the user
   * uses the sampling tab to sample Input 1 or Input 2).
   *
   * @return `true` if successful, `false` otherwise
   */
  bool load(SampleBuffers32 const &iSampleBuffers);

  /**
   * Executes the provided action on the current sample. Add current sample to undo history:
   *
   * - iAction + fCurrent stored as last UndoEntry
   * - iAction applied on fCurrent -> new fCurrent
   *
   * @return `true` if successful, `false` otherwise
   */
  bool executeAction(SampleDataAction const &iAction, bool clearRedoHistory = true);

  /**
   * Reverts the last action and add it to the redo history
   *
   * @return `true` if successful, `false` otherwise (or if nothing to undo)
   */
  bool undoLastAction();

  /**
   * Redo the last undone action.
   *
   * @return `true` if successful, `false` otherwise (or if nothing to redo)
   */
  bool redoLastUndo();

  // getLastUndoEntry
  inline UndoEntry const *getLastUndoEntry() const {
    return fUndoHistory.empty() ? nullptr : &fUndoHistory.front();
  }

  // getLastUndoAction
  inline SampleDataAction const *getLastUndoAction() const {
    return fRedoHistory.empty() ? nullptr : &fRedoHistory.front();
  }

  /**
   * Clears the entire undo/redo history
   *
   * @return `true` if there was anything to clear */
  bool clearActionHistory()
  {
    if(hasActionHistory())
    {
      fUndoHistory.clear();
      fRedoHistory.clear();
      return true;
    }
    return false;
  }

  // hasUndoHistory
  inline bool hasUndoHistory() const { return !fUndoHistory.empty(); }
  // hasRedoHistory
  inline bool hasRedoHistory() const { return !fRedoHistory.empty(); }
  // hasActionHistory
  inline bool hasActionHistory() const { return hasUndoHistory() || hasRedoHistory(); }

  // init
  void init(GUIJmbParam<SampleData> iSampleData) { fCurrent = iSampleData; }

protected:
  SampleData executeBufferAction(SampleDataAction const &iAction);

private:
  GUIJmbParam<SampleData> fCurrent{};
  std::forward_list<UndoEntry> fUndoHistory{};
  std::forward_list<SampleDataAction> fRedoHistory{};
};


}
}
}
